<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Plateau de jeu et dé 3D avec Babylon.js</title>
    <style>
        html, body {
            width: 100%;
            height: 100%;
            padding: 0;
            margin: 0;
            overflow: hidden;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }

        #rollDiceButton {
            position: absolute;
            bottom: 20px;
            right: 20px;
            font-size: 20px;
            padding: 10px;
        }
    </style>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script src="https://code.jquery.com/pep/0.4.3/pep.js"></script>
</head>

<body>
<canvas id="renderCanvas"></canvas>
<button id="rollDiceButton">Lancer le dé</button>
<script>
    window.addEventListener('DOMContentLoaded', function () {
        const canvas = document.getElementById('renderCanvas');
        const engine = new BABYLON.Engine(canvas, true);

        const diceTextures = [
            'img/one.png',
            'img/two.png',
            'img/three.png',
            'img/four.png',
            'img/five.png',
            'img/six.png'
        ];

        let currentPlayer = 0;
        const players = [];
        const challenges = [
            "Départ",
            "+3 gorgées",
            "Shot Mystère",
            "Pile ou Face",
            "-5 gorgées",
            "Péage",
            "+5 gorgées",
            "+1 shot",
            "-3 gorgées",
            "+2 shots",
            "-5 gorgées",
            "+2 shots",
            "-3 gorgées",
            "+1 shot",
            "+5 gorgées",
            "Péage",
            "-5 gorgées",
            "Pile ou Face",
            "Shot Mystère",
            "+3 gorgées",
        ];

        const tiles = [];
        let tilesOrder = [];
        const tilesImages = [
            'img/challenge/start.png',
            'img/challenge/plusThreeSlip.png',
            'img/challenge/mysteryShot.png',
            'img/challenge/pileFace.png',
            'img/challenge/minusFiveSlip.png',
            'img/challenge/peage.png',
            'img/challenge/plusFiveSlip.png',
            'img/challenge/plusOneShot.png',
            'img/challenge/minusThreeSlip.png',
            'img/challenge/plusTwoShot.png',
            'img/challenge/minusFiveSlip.png'
        ];
        const displayChallenge = (challengeText) => {
            const challengeTextMesh = new BABYLON.GUI.TextBlock();
            challengeTextMesh.text = challengeText;
            challengeTextMesh.color = "black";
            challengeTextMesh.fontSize = 24;
            let advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
            advancedTexture.addControl(challengeTextMesh);
            setTimeout(() => {
                advancedTexture.removeControl(challengeTextMesh);
            }, 2000);
        };

        const rollDice = (dice) => {
            const duration = 100;
            const initialRotation = dice.rotation.clone();
            const randomRotation = new BABYLON.Vector3(Math.random() * 2 * Math.PI, Math.random() * 2 * Math.PI, Math.random() * 2 * Math.PI);
            const randomNumber = Math.floor(Math.random() * 6) + 1;

            dice.material.diffuseTexture = new BABYLON.Texture(diceTextures[randomNumber - 1], scene);

            BABYLON.Animation.CreateAndStartAnimation('rollDiceAnimation', dice, 'rotation', 60, duration, initialRotation, initialRotation.add(randomRotation), BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);

            movePlayer(currentPlayer, randomNumber);
            currentPlayer = (currentPlayer + 1) % players.length;
        };

        const movePlayer = (playerIndex, steps) => {
            for (let i = 0; i < steps; i++) {
                setTimeout(() => {
                    const player = players[playerIndex];
                    player.currentTile += 1;

                    if (tilesOrder && player.currentTile >= tilesOrder.length) {
                        player.currentTile = 0;
                    }

                    if (tilesOrder) {
                        const nextTilePosition = tilesOrder[player.currentTile].position;

                        const moveAnimation = new BABYLON.Animation("moveAnimation", "position", 30, BABYLON.Animation
                            .ANIMATIONTYPE_VECTOR3, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
                        const keys = [];
                        keys.push({
                            frame: 0,
                            value: player.position
                        });
                        keys.push({
                            frame: 30,
                            value: new BABYLON.Vector3(nextTilePosition.x, player.position.y, nextTilePosition.z)
                        });
                        moveAnimation.setKeys(keys);

                        player.animations = [];
                        player.animations.push(moveAnimation);
                        scene.beginAnimation(player, 0, 30, false);
                    }
                }, i * 1000);
            }

            // Afficher le défi après que tous les mouvements du joueur aient été effectués
            setTimeout(() => {
                const currentChallengeIndex = players[playerIndex].currentTile % challenges.length;
                displayChallenge(challenges[currentChallengeIndex]);
            }, steps * 1000);
        };


        const createScene = function () {
            const scene = new BABYLON.Scene(engine);
            const advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");

            const camera = new BABYLON.ArcRotateCamera('camera', -Math.PI / 2, Math.PI / 4, 15, new BABYLON.Vector3(0, 0, 0), scene);
            camera.attachControl(canvas, true);

            const light = new BABYLON.HemisphericLight('light', new BABYLON.Vector3(0, 1, 0), scene);

            const board = BABYLON.MeshBuilder.CreateBox('board', {width: 6, height: 0.5, depth: 6}, scene);
            board.position.y = -1;

            const tileSize = 1;
            const tileSpacing = 0.1;
            const tilesPerRow = 6;
            const tilesPerColumn = 6;

            tilesOrder = [];
            const tiles = [];
            for (let row = 0; row < tilesPerRow; row++) {
                tiles[row] = [];
                for (let col = 0; col < tilesPerColumn; col++) {
                    // Seulement créer des cases sur le pourtour du plateau
                    if (row === 0 || row === tilesPerRow - 1 || col === 0 || col === tilesPerColumn - 1) {
                        let tile = BABYLON.MeshBuilder.CreateBox(`tile_${row}_${col}`, {width: tileSize, height: 0.1, depth: tileSize}, scene);
                        tile.position.x = (row - (tilesPerRow / 2)) * (tileSize + tileSpacing) + tileSize / 2;
                        tile.position.y = -0.7;
                        tile.position.z = (col - (tilesPerColumn / 2)) * (tileSize + tileSpacing) + tileSize / 2;

                        const tileMaterial = new BABYLON.StandardMaterial(`tileMaterial_${row}_${col}`, scene);
                        tileMaterial.diffuseTexture = new BABYLON.Texture(tilesImages[(row + col) % tilesImages.length], scene); // Change this line to choose a different image for each tile
                        tile.material = tileMaterial;

                        tiles[row][col] = tile;
                    }
                }
            }

            for (let col = 0; col < tilesPerColumn; col++) {
                if (tiles[0][col]) tilesOrder.push(tiles[0][col]);
            }

            for (let row = 1; row < tilesPerRow - 1; row++) {
                if (tiles[row][tilesPerColumn - 1]) tilesOrder.push(tiles[row][tilesPerColumn - 1]);
            }

            for (let col = tilesPerColumn - 1; col >= 0; col--) {
                if (tiles[tilesPerRow - 1][col]) tilesOrder.push(tiles[tilesPerRow - 1][col]);
            }

            for (let row = tilesPerRow - 2; row > 0; row--) {
                if (tiles[row][0]) tilesOrder.push(tiles[row][0]);
            }


            for (let i = 0; i < 2; i++) {
                const pawn = BABYLON.MeshBuilder.CreateCylinder(`pawn_${i}`, {diameter: 0.5, height: 1, tessellation: 32}, scene);
                pawn.position.y = 0;
                pawn.position.x = -2.5 + i;
                pawn.position.z = -2.5;
                pawn.currentTile = 0;
                players.push(pawn);
            }

            const dice = BABYLON.MeshBuilder.CreateBox('dice', {width: 1, height: 1, depth: 1}, scene);
            dice.position.y = 0.5;
            dice.position.x = 5;
            dice.position.z = 0;

            const diceMaterial = new BABYLON.StandardMaterial('diceMaterial', scene);
            diceMaterial.diffuseTexture = new BABYLON.Texture(diceTextures[0], scene);
            dice.material = diceMaterial;

            const challengeTextBlock = new BABYLON.GUI.TextBlock();
            challengeTextBlock.text = ""; // Le texte est vide au début
            challengeTextBlock.color = "white";
            challengeTextBlock.fontSize = 24;
            challengeTextBlock.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
            challengeTextBlock.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;
            advancedTexture.addControl(challengeTextBlock);

            return scene;
        };


        const scene = createScene();

        engine.runRenderLoop(function () {
            scene.render();
        });

        window.addEventListener('resize', function () {
            engine.resize();
        });

        document.getElementById('rollDiceButton').addEventListener('click', function () {
            rollDice(scene.getMeshByName('dice'));
        });
    });
</script>
</body>
</html>
